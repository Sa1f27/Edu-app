<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Stand-up Calls</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', sans-serif;
      background: #101010;
      color: #e0e0e0;
      text-align: center;
    }
    .header {
      padding: 20px;
      background: #181818;
      border-bottom: 1px solid #333;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    }
    h1 {
      margin: 0;
      font-size: 24px;
      color: #ffffff;
    }
    h2 {
      font-weight: 400;
      color: #aaa;
      margin-top: 8px;
      font-size: 16px;
    }
    .main-container {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 40px;
      margin: 30px auto;
      max-width: 800px;
    }
    .column {
      width: 120px;
      height: 120px;
      background: #1c1c1c;
      border-radius: 16px;
      box-shadow: 0 0 8px rgba(0, 0, 0, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .icon {
      width: 60px;
      height: 60px;
      opacity: 0.9;
    }
    .icon.blink {
      animation: pulse 1.4s infinite;
    }
    @keyframes pulse {
      0%   { transform: scale(1); opacity: 0.9; }
      50%  { transform: scale(1.1); opacity: 0.6; }
      100% { transform: scale(1); opacity: 0.9; }
    }
    #status {
      margin: 20px auto;
      font-size: 16px;
      color: #88aaff;
      max-width: 600px;
      word-wrap: break-word;
    }
    button {
      margin: 10px;
      padding: 10px 20px;
      border-radius: 6px;
      background-color: #2b6cb0;
      color: #fff;
      border: none;
      font-size: 14px;
      cursor: pointer;
    }
    button:hover {
      background-color: #1e4d80;
    }
    button:disabled {
      background-color: #555;
      cursor: not-allowed;
    }
    #evaluation {
      margin: 20px auto;
      max-width: 600px;
      padding: 15px;
      background: #1a1a1a;
      border-radius: 10px;
      color: #ccc;
      display: none;
      text-align: left;
      font-size: 14px;
    }
    #evaluation h3 {
      margin-top: 0;
      color: #e0e0e0;
    }
    #summaryText {
      white-space: pre-wrap;
    }
    #analytics {
      margin-top: 15px;
      font-style: italic;
      color: #aaa;
    }
    .recording-indicator {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin: 20px auto;
      color: #ff6b6b;
      font-weight: bold;
    }
    .recording-dot {
      width: 12px;
      height: 12px;
      background-color: #ff6b6b;
      border-radius: 50%;
      animation: recordingPulse 1s infinite;
    }
    @keyframes recordingPulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }
    .error-message {
      background: #ff6b6b;
      color: white;
      padding: 10px;
      border-radius: 5px;
      margin: 10px auto;
      max-width: 600px;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Stand-up Calls</h1>
    <h2 id="timerLabel">Time Left: 5:00</h2>
  </div>

  <div class="main-container">
    <div class="column">
      <img src="./static/icons/ai.png" id="aiIcon" class="icon" />
    </div>
    <div class="column">
      <img src="./static/icons/user.png" id="userIcon" class="icon" />
    </div>
  </div>

  <div id="status">Click Start to begin the test...</div>

  <div id="recordingIndicator" class="recording-indicator" style="display: none;">
    <div class="recording-dot"></div>
    <span>Recording... (speak now or pause to continue)</span>
  </div>

  <div class="controls">
    <button id="startBtn">‚ñ∂Ô∏è Start Test</button>
  </div>

  <div id="evaluation">
    <h3>üìä Interview Evaluation</h3>
    <div id="summaryText"></div>
    <div id="analytics"></div>
    <button id="retakeBtn">üîÑ Retake Interview</button>
    <button id="downloadPdfBtn" style="display:none;">‚¨áÔ∏è Download Results as PDF</button>
  </div>

  <script>
  let testActive = false;
  let isRecording = false;
  let testId = null;
  const startBtn = document.getElementById("startBtn");
  const retakeBtn = document.getElementById("retakeBtn");
  const status = document.getElementById("status");
  const timerLabel = document.getElementById("timerLabel");
  const evaluation = document.getElementById("evaluation");
  const summaryText = document.getElementById("summaryText");
  const analytics = document.getElementById("analytics");
  const aiIcon = document.getElementById("aiIcon");
  const userIcon = document.getElementById("userIcon");
  const downloadPdfBtn = document.getElementById("downloadPdfBtn");
  const recordingIndicator = document.getElementById("recordingIndicator");

  // Audio recording variables
  let mediaRecorder;
  let audioChunks = [];
  let audioContext;
  let analyser;
  let microphone;
  let dataArray;
  let silenceStart = null;
  let hasSpoken = false;

  // Silence detection configuration
  const SILENCE_THRESHOLD = 0.01;
  const SILENCE_DURATION = 1000; // 2 seconds in milliseconds
  const MAX_RECORDING_DURATION = 15000; // 15 seconds max
  const MIN_SPEAKING_DURATION = 1000; // Must speak for at least 1 second

  function log(message) {
    console.log(`[Client] ${message}`);
  }

  function blink(who) {
    aiIcon.classList.remove("blink");
    userIcon.classList.remove("blink");
    if (who === "ai") aiIcon.classList.add("blink");
    if (who === "user") userIcon.classList.add("blink");
    log(`Blinking: ${who || 'none'}`);
  }

  // FIXED: Added proper null/undefined checks
  function cleanText(text) {
    // Handle null, undefined, or non-string values
    if (!text || typeof text !== 'string') {
      return '';
    }
    return text.replace(/[*_#`]/g, "").replace(/\n/g, " ").trim();
  }

  // ADDED: Safe setter for status with validation
  function setStatus(text) {
    const safeText = cleanText(text) || 'Status update...';
    status.innerText = safeText;
    log(`Status: ${safeText}`);
  }

  function playAudio(src) {
    if (!src) return Promise.resolve();
    return new Promise(resolve => {
      const audio = new Audio(src);
      audio.onended = resolve;
      audio.onerror = (e) => {
        log(`Audio playback error: ${e}`);
        resolve();
      };
      audio.play().catch((e) => {
        log(`Audio play failed: ${e}`);
        resolve();
      });
    });
  }

  function countdown(endTime) {
    if (!testActive) return;
    const left = Math.max(0, Math.floor((endTime - Date.now()) / 1000));
    const m = String(Math.floor(left / 60)).padStart(1, "0");
    const s = String(left % 60).padStart(2, "0");
    timerLabel.innerText = `Time Left: ${m}:${s}`;
    if (left > 0) {
      setTimeout(() => countdown(endTime), 1000);
    } else {
      endTest("Test time limit reached.");
    }
  }

  function calculateRMS(buffer) {
    let sum = 0;
    for (let i = 0; i < buffer.length; i++) {
      sum += buffer[i] * buffer[i];
    }
    return Math.sqrt(sum / buffer.length);
  }

  function detectSilence() {
    if (!isRecording || !analyser) return;

    analyser.getFloatTimeDomainData(dataArray);
    const rms = calculateRMS(dataArray);
    const isSilent = rms < SILENCE_THRESHOLD;
    const now = Date.now();

    if (isSilent) {
      if (silenceStart === null) {
        silenceStart = now;
      } else if (hasSpoken && (now - silenceStart) > SILENCE_DURATION) {
        log(`Silence detected for ${SILENCE_DURATION}ms, stopping recording`);
        stopRecording();
        return;
      }
    } else {
      // Speaking detected
      silenceStart = null;
      if (!hasSpoken && rms > SILENCE_THRESHOLD * 3) { // Slightly higher threshold to confirm speaking
        hasSpoken = true;
        log("User started speaking");
      }
    }

    // Continue monitoring if still recording
    if (isRecording) {
      requestAnimationFrame(detectSilence);
    }
  }

  async function startRecording() {
    if (isRecording || !testActive) return;
    
    try {
      log("Starting recording with silence detection");
      isRecording = true;
      hasSpoken = false;
      silenceStart = null;
      audioChunks = [];
      
      blink("user");
      setStatus("Listening to your response...");
      recordingIndicator.style.display = "flex";

      // Get user media
      const stream = await navigator.mediaDevices.getUserMedia({ 
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          sampleRate: 16000
        } 
      });

      // Set up audio analysis for silence detection
      audioContext = new AudioContext({ sampleRate: 16000 });
      analyser = audioContext.createAnalyser();
      microphone = audioContext.createMediaStreamSource(stream);
      
      analyser.fftSize = 256;
      analyser.smoothingTimeConstant = 0.8;
      dataArray = new Float32Array(analyser.frequencyBinCount);
      
      microphone.connect(analyser);

      // Set up MediaRecorder
      mediaRecorder = new MediaRecorder(stream, {
        mimeType: 'audio/webm;codecs=opus'
      });

      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          audioChunks.push(event.data);
        }
      };

      mediaRecorder.onstop = async () => {
        log("MediaRecorder stopped, processing audio");
        
        // Clean up audio resources
        if (microphone) {
          microphone.disconnect();
        }
        if (audioContext) {
          await audioContext.close();
        }
        stream.getTracks().forEach(track => track.stop());

        // Process the recorded audio
        if (audioChunks.length > 0) {
          await processRecordedAudio();
        } else {
          log("No audio data recorded");
          if (testActive) {
            setStatus("No audio detected. Please try again...");
            setTimeout(() => startRecording(), 1000);
          }
        }
      };

      // Start recording
      mediaRecorder.start(100); // Collect data every 100ms

      // Start silence detection
      detectSilence();

      // Failsafe: stop recording after max duration
      setTimeout(() => {
        if (isRecording) {
          log("Max recording duration reached, stopping");
          stopRecording();
        }
      }, MAX_RECORDING_DURATION);

    } catch (error) {
      log(`Recording error: ${error.message}`);
      setStatus(`Recording error: ${error.message}`);
      endTest(`Recording error: ${error.message}`);
    }
  }

  function stopRecording() {
    if (!isRecording) return;
    
    log("Stopping recording");
    isRecording = false;
    recordingIndicator.style.display = "none";
    
    if (mediaRecorder && mediaRecorder.state !== "inactive") {
      mediaRecorder.stop();
    }
  }

  async function processRecordedAudio() {
    try {
      setStatus("Processing your response...");
      
      // Create blob from recorded chunks
      const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
      
      // Check if we have sufficient audio data
      if (audioBlob.size < 1000) { // Less than 1KB indicates very short recording
        log("Recording too short, requesting user to speak again");
        setStatus("Recording was too short. Please speak your answer...");
        setTimeout(() => startRecording(), 1000);
        return;
      }

      // Send to backend for processing
      const formData = new FormData();
      formData.append("audio", audioBlob, "response.webm");
      formData.append("test_id", testId);

      log("Sending audio to backend...");
      const response = await fetch("./record_and_respond", {
        method: "POST",
        body: formData,
      });

      const data = await response.json();
      log("Backend response received:", data);

      if (!response.ok) {
        throw new Error(data.error || "Recording processing failed");
      }

      // FIXED: Added validation for response data
      const responseText = data.response || "AI response not available";
      log(`Response received: ended=${data.ended}, response="${responseText}"`);
      
      setStatus(responseText);
      blink("ai");
      
      // Play AI response audio
      if (data.audio_path) {
        await playAudio(data.audio_path);
      }

      if (data.ended) {
        await showSummary();
        endTest("Test ended.");
      } else if (testActive) {
        // Continue with next question cycle
        setStatus("Please respond...");
        setTimeout(() => startRecording(), 1000); // Brief pause before next recording
      }

    } catch (error) {
      log(`Error processing audio: ${error.message}`);
      setStatus(`Error: ${error.message}`);
      endTest(`Error: ${error.message}`);
    }
  }

  async function showSummary() {
    try {
      log("Fetching test summary...");
      const response = await fetch(`./summary?test_id=${testId}`);
      const data = await response.json();
      
      log("Summary data received:", data);
      
      evaluation.style.display = "block";
      
      // FIXED: Added validation for summary data
      summaryText.innerText = data.summary || "Evaluation not available";
      
      if (data.analytics) {
        analytics.innerText = `Analytics:\nQuestions Answered: ${data.analytics.num_questions || 0}\nAvg. Response Length: ${data.analytics.avg_response_length || 0} words`;
      } else {
        analytics.innerText = "Analytics: Not available";
      }

      // Show and enable PDF download button if PDF URL is present
      if (data.pdf_url) {
        downloadPdfBtn.style.display = "inline-block";
        downloadPdfBtn.onclick = () => {
          window.location.href = data.pdf_url;
        };
      }
    } catch (e) {
      log(`Summary error: ${e.message}`);
      setStatus("Failed to load summary");
    }
  }

  function endTest(reason) {
    testActive = false;
    isRecording = false;
    startBtn.disabled = false;
    startBtn.innerText = "‚ñ∂Ô∏è Start Test";
    retakeBtn.disabled = false;
    recordingIndicator.style.display = "none";
    blink(null);
    setStatus(`Test ended: ${reason}`);
    
    // Clean up any active audio resources
    if (mediaRecorder && mediaRecorder.state !== "inactive") {
      mediaRecorder.stop();
    }
    if (audioContext) {
      audioContext.close();
    }
  }

  async function startTest() {
    if (testActive) return;
    testActive = true;
    isRecording = false;
    startBtn.disabled = true;
    startBtn.innerText = "‚è∫Ô∏è Recording";
    retakeBtn.disabled = true;
    evaluation.style.display = "none";
    setStatus("AI is asking a question...");
    blink("ai");

    try {
      log("Starting test...");
      const response = await fetch("./start_test");
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      log("Start test response:", data);
      
      // FIXED: Added validation for start test data
      if (!data.test_id) {
        throw new Error("No test ID received from server");
      }
      
      testId = data.test_id;
      const questionText = data.question || "Please tell me about today's topic.";
      
      setStatus(questionText);
      
      if (data.audio_path) {
        await playAudio(data.audio_path);
      }
      
      if (testActive) {
        setStatus("Please respond...");
        countdown(Date.now() + 300000); // 5 minute countdown
        setTimeout(() => startRecording(), 500); // Brief delay before starting recording
      }
    } catch (e) {
      log(`Start test error: ${e.message}`);
      setStatus(`Failed to start: ${e.message}`);
      startBtn.disabled = false;
      startBtn.innerText = "‚ñ∂Ô∏è Start Test";
      testActive = false;
    }
  }

  startBtn.onclick = startTest;
  retakeBtn.onclick = startTest;

  // Clean up on page unload
  window.addEventListener('beforeunload', () => {
    if (audioContext) {
      audioContext.close();
    }
  });

  // ADDED: Global error handler for debugging
  window.addEventListener('error', (e) => {
    log(`Global error: ${e.error?.message || e.message}`);
    setStatus(`Unexpected error: ${e.error?.message || e.message}`);
  });

  // ADDED: Unhandled promise rejection handler
  window.addEventListener('unhandledrejection', (e) => {
    log(`Unhandled promise rejection: ${e.reason}`);
    setStatus(`Promise error: ${e.reason}`);
  });
</script>

</body>
</html>